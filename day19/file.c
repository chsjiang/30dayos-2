#include "bootpack.h"

/* 
	fat (file allocation table) is a microsoft defined format to store file 
	fat table is auto generated by the img making tool
	file is not sotred consequtively, but stored by chunks of clustors each with 512 bytes.
	the clustors are to consequtive, meaning the first 512 bytes is clustor 0x01, the next might jump to 0x12
	therefore after reading the first clustor of a file, we need to check the fat table to find the next clustor to read
	
	since a floppy has 2880 clustors, it would need at least two bytes to represent them
		1 byte: 2^8 -1 = 255-> not enough!
		2 byte: 2^16 - 1 = 65535-> enough, but too much
	but 2 bytes is too much, microsoft invented a weird compression algorithm that crunches three clustor number into six bytes
		so each clustor number is represented by 1.5 byes
		1.5 byte: 2^12 - 1 = 4095-> enough
	the shufulling rule:
		'ab cd ef' would be read as 'dab efc'
	e.x 
		'03 40 00' means '003 004' -> that's two clustor number

*/
void file_readfat(int *fat, unsigned char *img) {
	int i, j= 0;
	for(i = 0; i < 2880; i += 2) {
		/* & 0xff to wipe out leading bits */
		fat[i] = (img[j] | (img[j+1] << 8) ) & 0xfff;
		fat[i+1] =  ((img[j+2] << 4) | (img[j+1] >> 4)) & 0xfff;
		j += 3;
	}
	return;
}

/* 
	since files are not stored consequtively, to ease reading, we allocate a chunk of memory 
		and copy the file content there according to the fat table
	then when we are actually reading it, we just need to read from that piece of memory consequtively
*/
void file_loadfile(int clustno, int size, char *buf, int *fat, char *img) {
	int i;
	for(;;) {
		if(size < 512) {
			for(i = 0; i < size; i++) {
				buf[i] = img[clustno * 512 + i];
			}
			break;
		}
		for(i = 0; i < 512; i++) {
			buf[i] = img[clustno * 512 + i];
		}
		size -= 512;
		buf += 512;
		/* 
			note fat is NOT consequtive, to get the successor of clustno, use fat[clustn] 
			fat[previous_clustno] = current_clustno
		*/
		clustno = fat[clustno];
	}
}

